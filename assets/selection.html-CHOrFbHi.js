import{_ as a,c as t,a as l,o as n}from"./app-DzEwyuga.js";const p={};function i(r,e){return n(),t("div",null,e[0]||(e[0]=[l('<h1 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h1><p>技术选型是每个团队都必不可免会接触到都一件事，我们经常面对的不只是单个技术的选型，而是对整体项目所涉及到的一整套方案、规范的选型。我们需要仔细去权衡各种技术，根据团队整体情况去考虑。</p><p>个人认为，技术选型需要先考虑一下几点：</p><ul><li>项目因素</li><li>团队因素</li><li>技术因素</li></ul><h2 id="项目因素" tabindex="-1"><a class="header-anchor" href="#项目因素"><span>项目因素</span></a></h2><p>明确项目周期、项目特点 明确项目的规模和重要程度，是玩票性质的快速探索类项目，还是正式项目稳扎稳打类项目</p><h3 id="项目周期" tabindex="-1"><a class="header-anchor" href="#项目周期"><span>项目周期</span></a></h3><p>对于短平快、玩票性质的快速探索类项目，比如各种独立的活动页，宣传页。什么顺手用什么。没必要太纠结技术选型。</p><p>对于正式、周期长、稳扎稳打类的项目，需要从整体去考虑</p><h3 id="项目特点" tabindex="-1"><a class="header-anchor" href="#项目特点"><span>项目特点</span></a></h3><p>对于企业官网之类需要考虑seo的项目，数据较为固定时，可以考虑现成的织梦、wordpress等建站工具。数据偏动态时，可以考虑nuxt.js和next.js。原则上我们不太去考虑spa之类的技术，虽然它们搭配webpack之类的构建工具可以做一些预渲染，但针对seo并没有上述两种方式友好。</p><p>对于需要跨端项目，考虑flutter、react native、uniapp等</p><h2 id="团队因素" tabindex="-1"><a class="header-anchor" href="#团队因素"><span>团队因素</span></a></h2><p>团队因素主要是考虑团队成员的因素。成员的技术栈、后期招聘成本、新人的学习成本</p><h3 id="成员技术栈" tabindex="-1"><a class="header-anchor" href="#成员技术栈"><span>成员技术栈</span></a></h3><p>首先需要考虑如果选择某个技术，实际开发中出现了bug，团队中是否能有人及时解决，而不是等官方主动修复。团队中一定能有对这个技术兜底的人。</p><p>其次考虑团队现有的技术积累，一般来讲，团队现有的技术积累在哪个框架，后续就可以延续之前的选择。这样步进减少了人员在项目切换的成本，也方便团队内部的技术积累，如后续封装组件库，公共代码复用等。</p><p>再考虑团队成员的技术栈，如果大家都擅长vue，很少或者不会react。那后续项目就尽量少用或不用react。如果从成员的职业角度考虑，后续可以在探索类项目中尝试去使用，但一定要有兜底的人。</p><h3 id="招聘成本" tabindex="-1"><a class="header-anchor" href="#招聘成本"><span>招聘成本</span></a></h3><p>选用技术栈直接影响到团队后续招聘成本，不只是金钱上的成本、还包括时间上的成本。</p><p>举个简单的例子，目前大部分前端的技术栈都是vue和react，这时候你偏要在项目中推行Angular。可以预见的是后续符合条件的人非常少。</p><h3 id="新人学习成本" tabindex="-1"><a class="header-anchor" href="#新人学习成本"><span>新人学习成本</span></a></h3><p>新成员入职后，我们希望他能尽快的适应团队，跟上团队的节奏，这时候技术选型就格外的重要。</p><p>比如，我项目就是一个中规中矩的vue项目，新成员来之后，一两天就可以上手。但如果我项目是一个自有的魔改的类vue框架，新成员还需要花费一到两周时间去适应，无形之中就耽误了大量的时间。</p><h2 id="技术因素" tabindex="-1"><a class="header-anchor" href="#技术因素"><span>技术因素</span></a></h2><p>技术因素考虑易用性、可维护性、可拓展性、性能、技术成熟度、社区活跃度、架构匹配和演化等。对于开源项目，github的star数，可以作为一个重要的参考依据。</p><h3 id="易用性" tabindex="-1"><a class="header-anchor" href="#易用性"><span>易用性</span></a></h3><p>通俗的来讲，易用性就是指的是该项技术好不好上手，容易不容易理解。如果两门技术各方面指标及应用场景差不多，易用性强的将成为赢家。</p><p>最典型的例子就是 Angular 和 Vue。Angular 学习曲线陡峭，需要比较长的学习时间；而 Vue 在熟练掌握 JavaScript 的情况下，看文档一两天就能上手干活。</p><h3 id="可维护性和可拓展性" tabindex="-1"><a class="header-anchor" href="#可维护性和可拓展性"><span>可维护性和可拓展性</span></a></h3><p>一方面指团队内部使用技术后的维护性和拓展性，项目是不断延伸的，不知道何时就会需要对该项技术要求二次开发。</p><p>另一方面指技术本身的可维护性和可拓展性。这方面可以通过社区的几个条件去区分</p><ul><li>社区是否活跃、配套设施是否全面</li><li>是否经常维护，可以通过代码提交记录查看</li><li>官方文档是否全面，官方文档都写不好的技术，大概率不是一门值得信任的技术</li><li>功能更新是否考虑向前兼容</li></ul><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h3><p>针对不同场景带来的不同性能表现，决定技术的使用场景。</p><p>如做小游戏开发，直接考虑游戏引擎，如Cocos，Egret、Layabox、Unity等</p><h2 id="其他因素" tabindex="-1"><a class="header-anchor" href="#其他因素"><span>其他因素</span></a></h2><p>此外还有一些额外因素需要考虑，比如许可协议的问题，前段时间闹得沸沸扬扬的 React Native 许可协议事件，相信大家记忆犹新。还有一些公司，可能对于使用第三方的程序或者服务，有一些原则甚至规范，那也一定要注意参考。另外，在稍大一些的公司里可能还会涉及一些派系之争，这里就不多说了。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>我们上面已经列出了很多技术选型需要考虑的因素，那么到底如何进行技术选型呢？大致上可以分为以下几个步骤：</p><p>首先要明确选型的需求和目的，最好能列出必须要考虑的各种因素以及评判标准。</p><p>然后就可以开始寻找候选技术或产品了。这时范围可以尽量广一些，搜集尽可能多的候选技术和产品。</p><p>其次就可以进行初步筛选。把一些由于各种限制无法选择的、或者明显不可能的技术或产品排除，筛选出 3 个左右备选方案。</p><p>再然后就要做一些详细的调查和分析了。可以列一个表格，把备选方案、以及需要考虑的因素放到表格的横向和纵向中去，一个个进行评估的分析。此时可能会需要做一些小 Demo 验证可行性，或者做一些性能测试、压力测试等等。必要的话可以在表格里给每一个因素打分。</p><p>最后，对分析结果进行评审，作出最后决定。</p><blockquote><p>技术选型分析表，每一格里可以有具体的打分，也可以有优势劣势的评价。</p></blockquote><table><thead><tr><th>候选A</th><th>候选B</th><th>候选C</th></tr></thead><tbody><tr><td>团队</td><td></td><td></td></tr><tr><td>技术成熟度</td><td></td><td></td></tr><tr><td>性能</td><td></td><td></td></tr><tr><td>架构一致性</td><td></td><td></td></tr><tr><td>...</td><td></td><td></td></tr></tbody></table><p>当然，小的不太重要的技术选型也不一定要这么麻烦，而重要的技术选型则可能要反复各个步骤多次。</p>',48)]))}const h=a(p,[["render",i],["__file","selection.html.vue"]]),d=JSON.parse('{"path":"/project/setUp/selection.html","title":"技术选型","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"项目因素","slug":"项目因素","link":"#项目因素","children":[{"level":3,"title":"项目周期","slug":"项目周期","link":"#项目周期","children":[]},{"level":3,"title":"项目特点","slug":"项目特点","link":"#项目特点","children":[]}]},{"level":2,"title":"团队因素","slug":"团队因素","link":"#团队因素","children":[{"level":3,"title":"成员技术栈","slug":"成员技术栈","link":"#成员技术栈","children":[]},{"level":3,"title":"招聘成本","slug":"招聘成本","link":"#招聘成本","children":[]},{"level":3,"title":"新人学习成本","slug":"新人学习成本","link":"#新人学习成本","children":[]}]},{"level":2,"title":"技术因素","slug":"技术因素","link":"#技术因素","children":[{"level":3,"title":"易用性","slug":"易用性","link":"#易用性","children":[]},{"level":3,"title":"可维护性和可拓展性","slug":"可维护性和可拓展性","link":"#可维护性和可拓展性","children":[]},{"level":3,"title":"性能","slug":"性能","link":"#性能","children":[]}]},{"level":2,"title":"其他因素","slug":"其他因素","link":"#其他因素","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"updatedTime":1733483676000,"contributors":[{"name":"gang.peng","username":"gang.peng","email":"gang.peng@szyh.com","commits":1,"url":"https://github.com/gang.peng"}]},"filePathRelative":"project/setUp/selection.md"}');export{h as comp,d as data};
