import{_ as n,c as a,a as e,o as p}from"./app-DzEwyuga.js";const t={};function l(o,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="常量和变量" tabindex="-1"><a class="header-anchor" href="#常量和变量"><span>常量和变量</span></a></h1><h2 id="常量" tabindex="-1"><a class="header-anchor" href="#常量"><span>常量</span></a></h2><p>虽然在 <code>Node.js</code> 中可以使用<code>let</code>、<code>var</code>、<code>const</code>等关键词创建一个变量，程序运行也不会报错。但在当前主流代码规范中，仍然会要求我们对于常量使用<code>const</code>关键词声明，并且全部字母都使用大写，并使用下划线分隔单词。部分严格的代码规范会要求对数字字面量插入下划线以提高可读性。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token constant">MAX_LENGTH</span> <span class="token operator">=</span> <span class="token number">100_000</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>很巧的是，在 <code>Rust</code> 中，对于常量的要求，也是一模一样的，并且更为严格一些</p><ol><li>常量使用<code>const</code>关键词声明</li><li>命名中全部字母都使用大写并使用下划线分隔单词</li><li>对数字字面量插入下划线</li><li>值的类型必须标注</li><li>常量自始至终不可变</li></ol><p>上述常量声明对应是</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token constant">MAX_LENGTH</span><span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">100_000</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>u32是 <code>Rust</code> 中的代码标注，表示类型声明，类似于TypeScript的写法。此处表示无符号32位整数，只能存储32位的非负整数值。</p></blockquote><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h2><h3 id="变量命名" tabindex="-1"><a class="header-anchor" href="#变量命名"><span>变量命名</span></a></h3><p><code>Rust</code> 中的变量命名跟 <code>Node.js</code> 没有区别，除了需要注意基本的规范外，还需要注意<a href="https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html" target="_blank" rel="noopener noreferrer">关键字</a>的规避。</p><h3 id="变量绑定" tabindex="-1"><a class="header-anchor" href="#变量绑定"><span>变量绑定</span></a></h3><p>在 <code>Node.js</code> 中，我们使用<code>var</code> 、 <code>let</code> 关键词对变量进行赋值，如</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>而在 <code>Rust</code> 中，只允许使用 <code>let</code> 对变量进行赋值，如</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述示例可以发现，<code>Rust</code> 中变量的声明，跟<code>Node.js</code>中的<code>let</code>用法一样，那么这里为什么要说是变量绑定呢，这是因为 <code>Rust</code> 中有一个核心原则——<strong>所有权</strong>，在后续的章节我们详细说明。这里简单理解为，<strong>在<code>Rust</code> 中，任何内存对象都有一个被称为所有者的变量，同时每个值也只有一个所有者</strong>。类似于一个绑定关系，所以这里称之为变量绑定</p><h3 id="变量可变性" tabindex="-1"><a class="header-anchor" href="#变量可变性"><span>变量可变性</span></a></h3><p>在 <code>Node.js</code> 中，任何变量都是可变的，如</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token string">&quot;Hello JavaScript&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述的操作在<code>Node.js</code>是被允许的。但在 <code>Rust</code> 中，变量在默认情况下是不可变的，一旦为变量绑定一个值，就不能再修改。比如上述代码转换为<code>Rust</code>后，</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token string">&quot;Hello JavaScript&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后运行，会报错</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">error<span class="token punctuation">[</span>E0384<span class="token punctuation">]</span>: cannot assign twice to immutable variable <span class="token variable"><span class="token variable">\`</span>a<span class="token variable">\`</span></span></span>
<span class="line"> --<span class="token operator">&gt;</span> src/main.rs:3:3</span>
<span class="line">  <span class="token operator">|</span></span>
<span class="line"><span class="token number">2</span> <span class="token operator">|</span>   <span class="token builtin class-name">let</span> a <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token operator">|</span>       -</span>
<span class="line">  <span class="token operator">|</span>       <span class="token operator">|</span></span>
<span class="line">  <span class="token operator">|</span>       first assignment to <span class="token variable"><span class="token variable">\`</span>a<span class="token variable">\`</span></span></span>
<span class="line">  <span class="token operator">|</span>       help: consider making this binding mutable: <span class="token variable"><span class="token variable">\`</span>mut a<span class="token variable">\`</span></span></span>
<span class="line"><span class="token number">3</span> <span class="token operator">|</span>   a <span class="token operator">=</span> <span class="token string">&quot;Hello JavaScript&quot;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token operator">|</span>   ^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的错误原因是 <code>cannot assign twice to immutable variable a</code>（无法对不可变的变量进行重复赋值），因为我们想为默认不可变的 a 变量再次赋值。</p><p>那可能有些同学就比较迷茫，不能改变值的为啥要叫变量？</p><p>其实这是 <code>Rust</code> 团队设计的语言特性之一。在实际开发中，我们经常遇到一个变量在多处代码中被使用，在其中一部分代码中，该变量的值永远不会发生变化，而在另一部分代码中，该变量的值会被改变。在这种场景编写代码错误，在运行前很难被发现，无形中增大了我们的工作量。</p><p><code>Rust</code>团队采用<code>变量默认不可变</code>的规则，让我们代码变得更加清晰，只有在你需要的变量发生变动时，才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。</p><p>在<code>Rust</code>中想让变量可变时，只需要在变量前增加一个关键字 <code>mut</code>，如</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token keyword">mut</span> <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token string">&quot;Hello JavaScript&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的显示声明也会让别人阅读你的代码时，下意识的明白，这个变量在后续会发生变更。</p><h3 id="变量遮蔽" tabindex="-1"><a class="header-anchor" href="#变量遮蔽"><span>变量遮蔽</span></a></h3><p><code>Node.js</code> 中有一个我们经常使用到，但可能忽略的特性，<code>变量遮蔽</code>，举个简单的例子</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 内部作用域中声明了一个名为 x 的变量，遮蔽了外部作用域的 x 变量</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Inner x:&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出内部作用域中的 x 变量，值为 20</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Outer x:&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 外部作用域中的 x 变量仍然可访问，值为 10</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，函数 <code>example</code> 内部声明了一个名为 <code>x</code> 的变量，它遮蔽了外部作用域中的 <code>x</code> 变量。在函数内部，通过 <code>console.log</code> 输出的 <code>x</code> 是内部作用域中的变量，其值为 <code>20</code>。而在函数外部，外部作用域中的 <code>x</code> 仍然是可访问的，其值为 <code>10</code>。</p><p>在 <code>Rust</code> 中同样的允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 内部作用域中重新声明了一个名为 x 的变量，遮蔽了外部作用域的 x 变量</span></span>
<span class="line">        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Inner x: {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出内部作用域中的 x 变量，值为 20</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Outer x: {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 外部作用域中的 x 变量仍然可访问，值为 10</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，内部作用域中的 <code>let x = 20;</code> 重新声明了一个名为 <code>x</code> 的变量，遮蔽了外部作用域中的 <code>x</code> 变量。在内部作用域中，通过 <code>println!</code> 输出的 <code>x</code> 是内部作用域中的变量，其值为 <code>20</code>。而在外部作用域中，外部作用域中的 <code>x</code> 仍然是可访问的，其值为 <code>10</code>。</p><p>细心的同学已经发现了，变量遮蔽和使用 <code>mut</code> 关键字不同，上述写法中 <code>let</code> 生成了一个新的变量，只是这个变量恰好跟之前的变量拥有同一个名字，涉及到内存对象的再分配。而 <code>mut</code> 关键字声明的变量，可以修改同一个内存地址上的值，并不会发生对象的再分配，性能要更好一些。</p><p>那既然 <code>mut</code> 关键字声明的方法性能会更好一些，为什么 <code>Rust</code> 要设计变量遮蔽的形式呢？</p><p>其实我们从之前的例子可以看出，变量遮蔽有助于避免命名冲突和意外的副作用，同时也提供了更灵活的命名空间。当然，过度使用变量遮蔽可能会导致代码可读性降低，因此应谨慎使用。</p>`,42)]))}const i=n(t,[["render",l],["__file","variable.html.vue"]]),d=JSON.parse('{"path":"/rust/dataType/variable.html","title":"常量和变量","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"常量","slug":"常量","link":"#常量","children":[]},{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[{"level":3,"title":"变量命名","slug":"变量命名","link":"#变量命名","children":[]},{"level":3,"title":"变量绑定","slug":"变量绑定","link":"#变量绑定","children":[]},{"level":3,"title":"变量可变性","slug":"变量可变性","link":"#变量可变性","children":[]},{"level":3,"title":"变量遮蔽","slug":"变量遮蔽","link":"#变量遮蔽","children":[]}]}],"git":{"updatedTime":1733483676000,"contributors":[{"name":"gang.peng","username":"gang.peng","email":"gang.peng@szyh.com","commits":1,"url":"https://github.com/gang.peng"}]},"filePathRelative":"rust/dataType/variable.md"}');export{i as comp,d as data};
