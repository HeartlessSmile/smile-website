import{_ as a}from"./vite-CBb_w8uL.js";import{_ as s,c as n,a as t,o as l}from"./app-DzEwyuga.js";const o="/smile-website/images/vite/dev.png",p="/smile-website/images/vite/plugin.png",c="/smile-website/images/vite/prd.png",i="/smile-website/images/vite/chunk.png",d={};function r(u,e){return l(),n("div",null,e[0]||(e[0]=[t('<h1 id="双引擎架构" tabindex="-1"><a class="header-anchor" href="#双引擎架构"><span>双引擎架构</span></a></h1><p><code>Vite</code> 的双引擎架构指的是在构建工具中同时使用 <code>Esbuild</code> 和 <code>Rollup</code> 两个现代构建引擎。这种架构使得 <code>Vite</code> 在开发阶段能够提供极快的热重载（HMR）和冷启动速度，同时在生产环境下生成优化的静态资源。</p><p><img src="'+a+'" alt="vite架构图"></p><h2 id="esbuild" tabindex="-1"><a class="header-anchor" href="#esbuild"><span>Esbuild</span></a></h2><p>从上述架构图，我们可以看出，在 <code>Vite</code> 很多关键的流程中，都有 <code>Esbuild</code> 的参与，我们按照架构图的流程逐步分析下。</p><h3 id="依赖预构建" tabindex="-1"><a class="header-anchor" href="#依赖预构建"><span>依赖预构建</span></a></h3><p><img src="'+o+'" alt="vite开发流程"></p><p><code>Vite</code> 在开发环境中，利用 <code>Esbuild</code> 对项目的依赖进行预构建。<code>Esbuild</code> 以其极快的构建速度，可以迅速处理大量的依赖项，使得项目能够快速启动。这对于开发者来说，大大减少了等待时间，提高了开发效率。</p><p>例如，在一个大型项目中，传统的构建工具可能需要几十秒甚至几分钟来完成依赖的预构建，而 <code>Esbuild</code> 可以在几秒钟内完成，让你几乎可以立即开始开发。</p><p>通过预构建，<code>Esbuild</code> 将一些 <code>CommonJS</code> 和 <code>UMD</code> 格式的依赖转换为 <code>ESM（ECMAScript Modules）</code>格式。这样可以更好地利用浏览器原生的 ESM 模块加载机制，减少模块加载的开销。同时，它还可以对依赖进行合并和优化，减少网络请求次数，提高应用的性能。</p><h3 id="单文件编译" tabindex="-1"><a class="header-anchor" href="#单文件编译"><span>单文件编译</span></a></h3><p><img src="'+p+'" alt="Vite Plugin Pipeline"></p><p>从上图中，我们可以知道在 <code>Vite Plugin Pipeline</code> 中，同样有 <code>Esbuild</code> 的身影，这是为了将 <code>Esbuild</code> 作为 <code>Transformer</code> 来进行代码转换， 也就是说 <code>Vite</code> 使用 <code>Esbuild</code> 将 <code>TypeScript</code>、<code>JSX</code> 等语法转换为浏览器可识别的 JavaScript 代码。</p><blockquote><p>Vite 已经将 Esbuild 的 Transformer 能力用到了生产环境</p></blockquote><p><code>Esbuild</code>的转换速度远远超过传统的构建工具，使得生产构建时间大大缩短。具体可以参考之前的 <a href="/advanced/esbuild/" target="_blank" rel="noopener noreferrer">Esbuild</a> 部分</p><h3 id="代码压缩" tabindex="-1"><a class="header-anchor" href="#代码压缩"><span>代码压缩</span></a></h3><blockquote><p>Vite 从 2.6 版本开始，就官宣默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。</p></blockquote><p><img src="'+c+`" alt="vite构建流程"></p><p>从架构图中，我们可以看到，<code>Esbuild</code> 的代码压缩功能以插件的形式集成到了 <code>Rollup</code> 的构建流程中。</p><p>这是因为 <code>Esbuild</code> 相比传统的压缩工具如 <code>Terser</code>，Esbuild 可以在几分钟的构建任务中节省几十秒甚至更多的时间，这在频繁构建的生产环境中积累起来是非常可观的效益。</p><p>并且 <code>Esbuild</code> 在压缩代码方面也非常高效。它能够快速地去除代码中的冗余部分，如不必要的空格、注释等，同时还能进行变量名压缩等优化操作，减小代码体积。这有助于提高网页的加载速度，提升用户体验。</p><h2 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup"><span>Rollup</span></a></h2><p><code>Rollup</code> 是 <code>Vite</code> 用作生产环境打包的核心工具, <code>Vite</code> 默认选择在生产环境中利用 <code>Rollup</code> 打包，并基于 <code>Rollup</code> 本身成熟的打包能力进行扩展和优化，主要包含以下几个方面:</p><h3 id="css-代码分割" tabindex="-1"><a class="header-anchor" href="#css-代码分割"><span>CSS 代码分割</span></a></h3><p>如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。</p><h3 id="自动预加载" tabindex="-1"><a class="header-anchor" href="#自动预加载"><span>自动预加载</span></a></h3><p>Vite 会自动为入口 chunk 的依赖自动生成预加载标签 <link rel="modulepreload"> ，如:</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token comment">&lt;!-- 省略其它内容 --&gt;</span></span>
<span class="line"><span class="token comment">&lt;!-- 入口 chunk --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/assets/index.250e0340.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token comment">&lt;!--  自动预加载入口 chunk 所依赖的 chunk--&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modulepreload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/assets/vendor.293dca09.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种适当预加载的做法会让浏览器提前下载好资源，优化页面性能。</p><h3 id="异步-chunk-加载优化" tabindex="-1"><a class="header-anchor" href="#异步-chunk-加载优化"><span>异步 Chunk 加载优化</span></a></h3><p>在异步引入的 Chunk 中，通常会有一些公用的模块，如现有两个异步引入的 Chunk: A 和 B，而且两者有一个公共依赖 C，如下图:</p><p><img src="`+i+'" alt="chunk 依赖"></p><p>一般情况下，<code>Rollup</code> 打包之后，会先请求 A，然后浏览器在加载 A 的过程中才决定请求和加载 C，但 <code>Vite</code> 进行优化之后，请求 A 的同时会自动预加载 C，通过优化 <code>Rollup</code> 产物依赖加载方式节省了不必要的网络开销。</p><h3 id="兼容插件机制" tabindex="-1"><a class="header-anchor" href="#兼容插件机制"><span>兼容插件机制</span></a></h3><p><code>Vite</code> 可以利用 <code>Rollup</code> 的插件体系来扩展其功能。许多常用的前端工具和库都提供了 <code>Rollup</code> 插件，<code>Vite</code> 可以通过集成这些插件来实现特定的功能。</p><p>例如，如果你需要在项目中使用 CSS 预处理器，可以安装 <code>Rollup</code> 的 CSS 预处理器插件，让 Vite 在构建过程中能够添加对 CSS 预处理器的支持。</p><p>在开发阶段，<code>Vite</code> 借鉴了 <a href="https://github.com/preactjs/wmr" target="_blank" rel="noopener noreferrer">WMR</a> 的思路，自己实现了一个 <code>Plugin Container</code>，用来模拟 <code>Rollup</code> 调度各个 <code>Vite</code> 插件的执行逻辑，而 <code>Vite</code> 的插件写法完全兼容 <code>Rollup</code>，因此在生产环境中将所有的 <code>Vite</code> 插件传入 Rollup 也没有问题。</p><p>反过来说，<code>Rollup</code> 插件却不一定能完全兼容 <code>Vite</code>。不过，目前仍然有不少 Rollup 插件可以直接复用到 Vite 中，你可以通过这个站点查看所有兼容 Vite 的 Rollup 插件: <a href="https://vite-rollup-plugins.patak.dev/" target="_blank" rel="noopener noreferrer">vite-rollup-plugins.patak.dev/</a> 。</p><h2 id="vite-双引擎架构的优势" tabindex="-1"><a class="header-anchor" href="#vite-双引擎架构的优势"><span>Vite 双引擎架构的优势</span></a></h2><h3 id="_1-极快的冷启动" tabindex="-1"><a class="header-anchor" href="#_1-极快的冷启动"><span>1. <strong>极快的冷启动</strong></span></a></h3><p>传统构建工具 (如 Webpack) 在启动开发服务器时，通常需要进行一次完整的打包，特别是在大型项目中，冷启动时间可能会很长。而 Vite 通过直接利用 ESModules，避免了冷启动时的打包过程，因此启动速度极快。</p><h3 id="_2-模块热更新-hmr-更高效" tabindex="-1"><a class="header-anchor" href="#_2-模块热更新-hmr-更高效"><span>2. <strong>模块热更新 (HMR) 更高效</strong></span></a></h3><p>Vite 只更新修改的模块，而不是重新打包和加载整个应用程序，这大大减少了开发过程中的等待时间。由于 HMR 的基础是 ESModules，Vite 能够精确地知道哪些模块需要重新编译，哪些可以保持不变。</p><h3 id="_3-按需编译" tabindex="-1"><a class="header-anchor" href="#_3-按需编译"><span>3. <strong>按需编译</strong></span></a></h3><p>Vite 的按需编译机制避免了整个项目的打包，只有在请求时才会编译模块。因此，无论项目多大，初次加载的速度都很快。而且因为是模块化请求，用户仅在需要时才会加载某些依赖，避免了不必要的资源浪费。</p><h3 id="_4-生产环境的高效打包" tabindex="-1"><a class="header-anchor" href="#_4-生产环境的高效打包"><span>4. <strong>生产环境的高效打包</strong></span></a></h3><p>生产环境下，Vite 通过 <code>Rollup</code> 进行打包， 利用 <code>Rollup</code> 强大的树摇和代码拆分功能，使得最终生成的代码包尽可能小。这保证了生产环境中的加载速度和性能。</p>',47)]))}const k=s(d,[["render",r],["__file","engines.html.vue"]]),m=JSON.parse('{"path":"/advanced/vite/engines.html","title":"双引擎架构","lang":"zh-CN","frontmatter":{"sidebarDepth":2},"headers":[{"level":2,"title":"Esbuild","slug":"esbuild","link":"#esbuild","children":[{"level":3,"title":"依赖预构建","slug":"依赖预构建","link":"#依赖预构建","children":[]},{"level":3,"title":"单文件编译","slug":"单文件编译","link":"#单文件编译","children":[]},{"level":3,"title":"代码压缩","slug":"代码压缩","link":"#代码压缩","children":[]}]},{"level":2,"title":"Rollup","slug":"rollup","link":"#rollup","children":[{"level":3,"title":"CSS 代码分割","slug":"css-代码分割","link":"#css-代码分割","children":[]},{"level":3,"title":"自动预加载","slug":"自动预加载","link":"#自动预加载","children":[]},{"level":3,"title":"异步 Chunk 加载优化","slug":"异步-chunk-加载优化","link":"#异步-chunk-加载优化","children":[]},{"level":3,"title":"兼容插件机制","slug":"兼容插件机制","link":"#兼容插件机制","children":[]}]},{"level":2,"title":"Vite 双引擎架构的优势","slug":"vite-双引擎架构的优势","link":"#vite-双引擎架构的优势","children":[{"level":3,"title":"1. 极快的冷启动","slug":"_1-极快的冷启动","link":"#_1-极快的冷启动","children":[]},{"level":3,"title":"2. 模块热更新 (HMR) 更高效","slug":"_2-模块热更新-hmr-更高效","link":"#_2-模块热更新-hmr-更高效","children":[]},{"level":3,"title":"3. 按需编译","slug":"_3-按需编译","link":"#_3-按需编译","children":[]},{"level":3,"title":"4. 生产环境的高效打包","slug":"_4-生产环境的高效打包","link":"#_4-生产环境的高效打包","children":[]}]}],"git":{"updatedTime":1733483676000,"contributors":[{"name":"gang.peng","username":"gang.peng","email":"gang.peng@szyh.com","commits":1,"url":"https://github.com/gang.peng"}]},"filePathRelative":"advanced/vite/engines.md"}');export{k as comp,m as data};
